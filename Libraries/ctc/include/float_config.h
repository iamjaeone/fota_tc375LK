/**************************************************************************
**                                                                        *
**  FILE        :  float_config.h                                         *
**                                                                        *
**  DESCRIPTION :  Configuration of the floating-point support for a      *
**                 target. Used in libc and libfloat.                     *
**                                                                        *
**  Copyright 1996-2022 Altium BV                                         *
**                                                                        *
**************************************************************************/

#ifndef FLOAT_CONFIG_H_INCLUDED
#define FLOAT_CONFIG_H_INCLUDED

/**
 * Configuration of the TASKING floating-point support.
 *
 * For an implementation that is fully conformant to IEEE 754-1985 
 * all of FP_SUPPORT_INFNAN, FP_SUPPORT_EXCEPTIONS, FP_SUPPORT_NEGZERO, and
 * FP_SUPPORT_TRAPS shoulde be defined as 1. In cases where more compact
 * and faster code is prefered over full conformance to the standard
 * some of these values can be defined as 0.
 */

/**
 * Define as 1 if subnormals should be supported, or as 0 if they
 * should not be supported.
 *
 * If subnormals are not supported, subnormals are never generated by
 * the floating-point functions, and any subnormals that are given as input
 * produce an unspecified result.
 */
#define FP_SUPPORT_SUBNORMALS   (1)

/**
 * Define as 1 if subnormals should be evaluated and returned, or as 0 if 
 * they should be interpreted as 0, and never returned.
 *
 * This #define is only effective if FP_SUPPORT_SUBNORMALS is 1.
 */
#define FP_EVALUATE_SUBNORMALS  (0)

/**
 * Define as 1 if NAN and INFINITY should be supported, or as 0 if they
 * should not be supported.
 *
 * If NAN and INFINITY are not supported, we ignore the possibility that
 * input values could be NAN or INFINITY. We may or may not produce
 * INFINITY our NAN from our own code if the correct result is one of
 * these values.
 */
#define FP_SUPPORT_NANINF       (1)

/**
 * Define as 1 if negative zero should be supported, or as 0 if it
 * should not be supported.
 */
#define FP_SUPPORT_NEGZERO      (1)

/**
 * Define as 1 if all floating-point exceptions should be raised
 * correctly according to IEEE 754-1985, or 0 if no exceptions should
 * ever be raised.
 */
#define FP_SUPPORT_EXCEPTIONS   (1)

/**
 * Define as 1 if should be possible to trap floating-point exceptions, or
 * 0 if no exceptions will ever be trapped.
 *
 * FIXME: implement support for trapping.
 */
#define FP_SUPPORT_TRAPPING     (1)

/**
 * Define as 1 if should be possible to use different rounding modes, or
 * 0 if all computations are done using the default rounding mode (FE_TONEAREST).
 *
 * FIXME: implement support for trapping.
 */
#define FP_SUPPORT_ROUNDING_MODES       (1)

/**
 * Define as 1 if the fallback fenv implementation in libfloat should be used,
 * or as 0 if it should not be used.
 *
 * This #define is only effective if FP_SUPPORT_EXCEPTIONS is 1.
 */
#define FP_USE_FALLBACK_FENV (1)

/**
 * Definitions for floating-point exception flags.
 *
 * If relevant, the bit numbers are chosen to correspond with status
 * register bits of the target hardware.
 */
#define TASKING_FE_DIVBYZERO    (1 << 4)
#define TASKING_FE_INEXACT      (1 << 2)
#define TASKING_FE_INVALID      (1 << 6)
#define TASKING_FE_OVERFLOW     (1 << 5)
#define TASKING_FE_UNDERFLOW    (1 << 3)

/**
 * Rounding modes and their encoding in the platform hardware.
 */
#define TASKING_FE_TONEAREST    (0)
#define TASKING_FE_UPWARD       (1)
#define TASKING_FE_DOWNWARD     (2)
#define TASKING_FE_TOWARDZERO   (3)


#define TASKING_FLT_MAX         (0xf.fffffp+124f)
#define TASKING_FLT_MIN         (0x1p-126f)
#define TASKING_DBL_MAX         (0xf.ffffffffffff8p+1020)
#define TASKING_DBL_MIN         (0x1p-1022)

/* The IEEE formats that TASKING compilers support always have a
 * representation of INFINITY and NAN. In some cases we may
 * assume that these never occor, though.
 */
#ifdef __cplusplus
#define TASKING_NAN       (0.0f/0.0f)
#define TASKING_INFINITY  (1.0f/0.0f)
#else
/* Don't complain about overflow. */
/* Don't complain about division by zero. */
#define TASKING_NAN (_Pragma("STDC FENV_ACCESS OFF") _Pragma("warning 585") (0.0f/0.0f) _Pragma("warning restore") _Pragma("STDC FENV_ACCESS restore"))
#define TASKING_INFINITY (_Pragma("STDC FENV_ACCESS OFF") _Pragma("warning 527") (TASKING_FLT_MAX*16) _Pragma("warning restore") _Pragma("STDC FENV_ACCESS restore"))
#endif

#define TASKING_HUGE_VAL        (TASKING_INFINITY)
#define TASKING_HUGE_VALF       (TASKING_INFINITY)
#define TASKING_NAN_STANDIN     TASKING_NAN

/* Disabling some features renders some if() conditions constant.
 * We don't want warnings about these, so disable the warning at those
 * particular places.
 */
// FIXME: actually disable warnings
#define NO_CONSTANT_WARNING(x)  (x)

#if FP_SUPPORT_NANINF
#define IS_FLT_NANINF_EXP(exp) ( ((int) (exp)) == FLT_BIASED_INF_EXP )
#define IS_DBL_NANINF_EXP(exp) ( ((int) (exp)) == DBL_BIASED_INF_EXP )
#else
#define IS_FLT_NANINF_EXP(exp) (NO_CONSTANT_WARNING(false))
#define IS_DBL_NANINF_EXP(exp) (NO_CONSTANT_WARNING(false))
#endif

#if FP_SUPPORT_SUBNORMALS
#define IS_FLT_NORMAL_EXP(exp) ( (exp) != 0 )
#define IS_DBL_NORMAL_EXP(exp) ( (exp) != 0 )
#else
// Since we ignore subnormals, we also ignore the possibility that
// there can be an exponent for a subnormal.
#define IS_FLT_NORMAL_EXP(exp) (NO_CONSTANT_WARNING(true))
#define IS_DBL_NORMAL_EXP(exp) (NO_CONSTANT_WARNING(true))
#endif

#endif  // Include guard
